[
  {
    "name": "Single Responsibility Principle",
    "description": "A class should have only one reason to change.",
    "rationale": "This principle helps to keep classes focused and maintainable by ensuring they only handle one responsibility.",
    "example": [
      "// Single Responsibility Principle Example",
      "// The UserService class is responsible only for user-related operations.",
      "class UserService {",
      "  constructor(userRepository) {",
      "    this.userRepository = userRepository;",
      "  }",
      "",
      "  createUser(userData) {",
      "    return this.userRepository.save(userData);",
      "  }",
      "}",
      "",
      "// A separate Logger class is responsible only for logging operations",
      "class Logger {",
      "  log(message) {",
      "    console.log(`[LOG]: ${message}`);",
      "  }",
      "}"
    ]
  },
  {
    "name": "Open-Closed Principle",
    "description": "Classes should be open for extension but closed for modification.",
    "rationale": "This principle promotes extendable and stable code by allowing new features via subclassing rather than modifying existing classes.",
    "example": [
      "// Open-Closed Principle Example",
      "// The Notification class can be extended without modifying its existing functionality.",
      "class Notification {",
      "  send(message) {",
      "    throw new Error('send() must be implemented by subclasses');",
      "  }",
      "}",
      "",
      "class EmailNotification extends Notification {",
      "  send(message) {",
      "    console.log(`Sending email with message: ${message}`);",
      "  }",
      "}",
      "",
      "class SMSNotification extends Notification {",
      "  send(message) {",
      "    console.log(`Sending SMS with message: ${message}`);",
      "  }",
      "}"
    ]
  },
  {
    "name": "Liskov Substitution Principle",
    "description": "Objects of a superclass should be replaceable with objects of a subclass without altering the correctness of the program.",
    "rationale": "Ensures subclasses are fully compatible with their base class, making the system more predictable.",
    "example": [
      "// Liskov Substitution Principle Example",
      "// The Rectangle class is designed so that its subclass Square can be used interchangeably.",
      "class Rectangle {",
      "  constructor(width, height) {",
      "    this.width = width;",
      "    this.height = height;",
      "  }",
      "",
      "  getArea() {",
      "    return this.width * this.height;",
      "  }",
      "}",
      "",
      "class Square extends Rectangle {",
      "  constructor(side) {",
      "    super(side, side);",
      "  }",
      "}",
      "",
      "function printArea(shape) {",
      "  console.log(shape.getArea());",
      "}",
      "",
      "const rectangle = new Rectangle(5, 10);",
      "const square = new Square(5);",
      "printArea(rectangle); // Works",
      "printArea(square); // Also works"
    ]
  },
  {
    "name": "Interface Segregation Principle",
    "description": "No client should be forced to depend on methods it does not use.",
    "rationale": "This principle prevents classes from having unnecessary dependencies by splitting interfaces into smaller, specific interfaces.",
    "example": [
      "// Interface Segregation Principle Example",
      "// Separate interfaces for FileUploader and MetadataEditor",
      "class FileUploader {",
      "  upload(file) {",
      "    console.log(`Uploading ${file}...`);",
      "  }",
      "}",
      "",
      "class MetadataEditor {",
      "  editMetadata(file, metadata) {",
      "    console.log(`Editing metadata of ${file} with ${metadata}`);",
      "  }",
      "}",
      "",
      "const uploader = new FileUploader();",
      "uploader.upload('file.txt'); // Only depends on the upload function"
    ]
  },
  {
    "name": "Dependency Inversion Principle",
    "description": "High-level modules should not depend on low-level modules but on abstractions.",
    "rationale": "This allows for flexible and reusable components by abstracting away specific implementations.",
    "example": [
      "// Dependency Inversion Principle Example",
      "// PaymentService depends on PaymentGateway abstraction",
      "class PaymentService {",
      "  constructor(paymentGateway) {",
      "    this.paymentGateway = paymentGateway;",
      "  }",
      "",
      "  processPayment(amount) {",
      "    this.paymentGateway.pay(amount);",
      "  }",
      "}",
      "",
      "class StripePaymentGateway {",
      "  pay(amount) {",
      "    console.log(`Processing payment of $${amount} through Stripe.`);",
      "  }",
      "}",
      "",
      "const stripeGateway = new StripePaymentGateway();",
      "const paymentService = new PaymentService(stripeGateway);",
      "paymentService.processPayment(100);"
    ]
  },
  {
    "name": "DRY (Don't Repeat Yourself)",
    "description": "Avoid duplication in code by abstracting repeated logic.",
    "rationale": "Keeps code concise and reduces the risk of inconsistencies by centralizing logic.",
    "example": [
      "// DRY Principle Example",
      "// Centralizing date formatting logic in a utility function",
      "function formatDate(date) {",
      "  return new Intl.DateTimeFormat('en-US').format(date);",
      "}",
      "",
      "class User {",
      "  constructor(name, birthDate) {",
      "    this.name = name;",
      "    this.birthDate = birthDate;",
      "  }",
      "",
      "  getFormattedBirthDate() {",
      "    return formatDate(this.birthDate);",
      "  }",
      "}",
      "",
      "const user = new User('Alice', new Date(1990, 5, 15));",
      "console.log(user.getFormattedBirthDate());"
    ]
  },
  {
    "name": "KISS (Keep It Simple, Stupid)",
    "description": "Simplicity is preferred over complexity; avoid over-engineering.",
    "rationale": "Simple code is easier to maintain and less prone to errors.",
    "example": [
      "// KISS Principle Example",
      "// Using a simple function for basic validation",
      "function isValidEmail(email) {",
      "  return email.includes('@');",
      "}",
      "",
      "console.log(isValidEmail('user@example.com')); // true",
      "console.log(isValidEmail('userexample.com')); // false",
      "// No need for complex regular expressions if basic validation suffices"
    ]
  },
  {
    "name": "YAGNI (You Aren't Gonna Need It)",
    "description": "Do not add functionality until it is necessary.",
    "rationale": "Prevents feature bloat by focusing on current requirements.",
    "example": [
      "// YAGNI Principle Example",
      "// Adding caching only when it's necessary",
      "class ApiService {",
      "  constructor() {",
      "    this.cache = {};",
      "  }",
      "",
      "  fetchData(endpoint) {",
      "    if (!this.cache[endpoint]) {",
      "      console.log(`Fetching data from ${endpoint}`);",
      "      this.cache[endpoint] = `Data from ${endpoint}`; // Simulate fetching",
      "    }",
      "    return this.cache[endpoint];",
      "  }",
      "}",
      "",
      "const apiService = new ApiService();",
      "console.log(apiService.fetchData('/users')); // Fetches data",
      "console.log(apiService.fetchData('/users')); // Returns cached data"
    ]
  },
  {
    "name": "Encapsulation",
    "description": "Bundle data and methods that work on the data within one unit (e.g., a class).",
    "rationale": "Encapsulation restricts direct access to some of an object's components, improving modularity.",
    "example": [
      "// Encapsulation Example",
      "// BankAccount hides its balance and provides methods to interact with it",
      "class BankAccount {",
      "  #balance;",
      "",
      "  constructor(initialBalance) {",
      "    this.#balance = initialBalance;",
      "  }",
      "",
      "  deposit(amount) {",
      "    if (amount > 0) this.#balance += amount;",
      "  }",
      "",
      "  withdraw(amount) {",
      "    if (amount > 0 && amount <= this.#balance) this.#balance -= amount;",
      "  }",
      "",
      "  getBalance() {",
      "    return this.#balance;",
      "  }",
      "}",
      "",
      "const account = new BankAccount(100);",
      "account.deposit(50);",
      "console.log(account.getBalance()); // 150"
    ]
  },
  {
    "name": "Separation of Concerns",
    "description": "Different concerns should be handled by different modules/classes.",
    "rationale": "This principle helps to organize code and promotes modularity by dividing code into distinct sections.",
    "example": [
      "// Separation of Concerns Example",
      "// UserController handles HTTP requests, UserService handles business logic",
      "class UserService {",
      "  createUser(userData) {",
      "    console.log('User created with data:', userData);",
      "  }",
      "}",
      "",
      "class UserController {",
      "  constructor(userService) {",
      "    this.userService = userService;",
      "  }",
      "",
      "  handleCreateUserRequest(request) {",
      "    const userData = request.body;",
      "    this.userService.createUser(userData);",
      "  }",
      "}",
      "",
      "const userService = new UserService();",
      "const userController = new UserController(userService);",
      "userController.handleCreateUserRequest({ body: { name: 'John' } });"
    ]
  }
]
